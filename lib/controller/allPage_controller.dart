import 'dart:convert';
import 'package:get/get.dart';
import 'package:firebase_remote_config/firebase_remote_config.dart';
import 'package:get_storage/get_storage.dart';
import 'package:loan/cache/users_response.dart';
import 'package:loan/global_functions/checkConnectivity.dart';


class SurveyController extends GetxController {
  final FirebaseRemoteConfig _remoteConfig = FirebaseRemoteConfig.instance;
  final UserCacheService _cacheService = UserCacheService();

  var questions = <Map<String, dynamic>>[].obs;
  var isLoading = false.obs;
  var isConnected = false.obs;
  final RxBool isSnackbarShown = false.obs;
  final RxBool isCOGSScreenSnackbarShown = false.obs;
  final RxBool isOperatingScreenSnackbarShown = false.obs;
  final RxBool isPersonalCostSnackbarShown = false.obs;
  final RxBool isBusinessNonFinancialSnackbarShown = false.obs;


  @override
  void onInit() {
    super.onInit();
    checkStatusAndFetchQuestions('default_key'); // Provide a default key
  }

  void loadCachedQuestions(String key) {
    var cachedData = _cacheService.getCachedQuestions(key);
    if (cachedData != null) {
      questions.value = cachedData;
      print('Loaded cached questions for key $key: ${questions.value}');
    } else {
      print('No cached questions found for key $key.');
      
      // If we're looking for application submission questions and cache is empty, load test data
      if (key == 'application_submission_questions') {
        loadTestApplicationSubmissionQuestions();
      }
    }
  }

  // Load test application submission questions for development
  void loadTestApplicationSubmissionQuestions() {
    print('Loading test application submission questions');
    
    questions.value = [
      {
        "id": 1,
        "text": {
          "en": "Application form was filled out at this location",
          "hi": "इस स्थान पर आवेदन पत्र भरा गया था"
        },
        "keyboardType": "dropdown",
        "questionType": "dropdown",
        "label": "Form_Filled_Location",
        "options": {
          "en": [
            "At Applicant's shop/business location",
            "At Applicant's home",
            "At the branch",
            "Other Location"
          ],
          "hi": [
            "आवेदक की दुकान/व्यावसायिक स्थान पर",
            "आवेदक के घर पर",
            "शाखा में",
            "अन्य स्थान"
          ]
        }
      },
      {
        "id": 2,
        "text": {
          "en": "Location of shop/establishment",
          "hi": "दुकान/प्रतिष्ठान का स्थान"
        },
        "keyboardType": "gps",
        "questionType": "gps",
        "label": "Shop_Location",
        "autoGenerated": true
      },
      {
        "id": 3,
        "text": {
          "en": "Date Time Stamp",
          "hi": "दिनांक समय टिकट"
        },
        "keyboardType": "datetime",
        "questionType": "datetime",
        "label": "Date_Time_Stamp",
        "autoGenerated": true
      }
    ];
    
    // Cache the test questions
    _cacheService.cacheQuestions('application_submission_questions', questions.value);
  }

  Future<void> checkStatusAndFetchQuestions(String key) async {
    isLoading.value = true;
    isConnected.value = await isConnectedToInternet();

    if (isConnected.value) {
      await fetchSurveyQuestions(key);
      
      // If questions are still empty and we're looking for application submission questions,
      // load test data as a fallback
      if (questions.isEmpty && key == 'application_submission_questions') {
        loadTestApplicationSubmissionQuestions();
      }
    } else {
      loadCachedQuestions(key);
    }

    isLoading.value = false;
  }

  Future<String> questionData(String key) async {
    return _remoteConfig.getString(key);
  }

  Future<void> fetchSurveyQuestions(String key) async {
    print(key);
    try {
      await _remoteConfig.setConfigSettings(
        RemoteConfigSettings(
          fetchTimeout: const Duration(seconds: 10),
          minimumFetchInterval: Duration.zero,
        ),
      );

      await _remoteConfig.fetchAndActivate();

      String questionsData = await questionData(key);

      if (questionsData.isNotEmpty) {
        var decodedData = jsonDecode(questionsData);
        print('Decoded Data from Remote Config for key $key: $decodedData');

        // Ensure the correct key is used to retrieve questions
        if (decodedData[key] != null) {
          questions.value = List<Map<String, dynamic>>.from(decodedData[key]);
          print('Parsed questions: ${questions.value}');

          // Cache the questions using the key
          _cacheService.cacheQuestions(key, questions.value);
        } else {
          print('No "$key" key found in the fetched data.');
          
          // If we're looking for application submission questions and they're not found,
          // load test data as a fallback
          if (key == 'application_submission_questions') {
            loadTestApplicationSubmissionQuestions();
          }
        }
      } else {
        print('Questions data is empty.');
        
        // If we're looking for application submission questions and data is empty,
        // load test data as a fallback
        if (key == 'application_submission_questions') {
          loadTestApplicationSubmissionQuestions();
        }
      }
    } catch (e) {
      print('Error fetching survey questions: $e');
      Get.snackbar('Error', 'Failed to load the questions.');
      
      // If there's an error and we're looking for application submission questions,
      // load test data as a fallback
      if (key == 'application_submission_questions') {
        loadTestApplicationSubmissionQuestions();
      }
    }
  }
}
